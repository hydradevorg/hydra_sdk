#!/bin/bash
# Modernized script to build Hydra SDK components as WebAssembly modules

# Display help information
show_help() {
  echo "Hydra SDK WebAssembly Build Script"
  echo "===================================="
  echo "This script builds selected Hydra SDK components to WebAssembly for use in web applications."
  echo ""
  echo "Usage: $0 [options]"
  echo ""
  echo "Options:"
  echo "  -h, --help          Show this help message"
  echo "  -m, --module NAME   Build specific module (crypto, address, vfs, lmvs, all)"
  echo "  -d, --debug         Build with debug symbols"
  echo "  -v, --verbose       Show verbose output"
  echo ""
  echo "Examples:"
  echo "  $0 --module crypto     # Build only the crypto module"
  echo "  $0 --module all        # Build all modules"
  echo "  $0 --debug             # Build all modules with debug symbols"
}

# Parse command line arguments
MODULE="all"
DEBUG=0
VERBOSE=0

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      show_help
      exit 0
      ;;
    -m|--module)
      MODULE="$2"
      shift 2
      ;;
    -d|--debug)
      DEBUG=1
      shift
      ;;
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    *)
      echo "Unknown option: $1"
      show_help
      exit 1
      ;;
  esac
done

# Set directories
HYDRA_ROOT="/volumes/bigcode/hydra_sdk"
BUILD_DIR="${HYDRA_ROOT}/build_wasm"
OUTPUT_DIR="${HYDRA_ROOT}/wasm_modules"

# Check if Emscripten is properly configured
if ! command -v emcc &> /dev/null; then
  echo "Error: Emscripten compiler (emcc) not found."
  echo "Please ensure Emscripten is installed and activated:"
  echo "1. Install: git clone https://github.com/emscripten-core/emsdk.git"
  echo "2. Update:  cd emsdk && ./emsdk install latest && ./emsdk activate latest"
  echo "3. Source:  source ./emsdk_env.sh"
  exit 1
fi

# Get Emscripten version
EMCC_VERSION=$(emcc --version | head -n1 | cut -d'(' -f1 | sed 's/^.*: //' | xargs)
echo "Using Emscripten version: $EMCC_VERSION"

# Create directories
mkdir -p "${BUILD_DIR}"
mkdir -p "${OUTPUT_DIR}"

# Create CMake toolchain file based on detected Emscripten version
create_toolchain_file() {
  echo "Creating CMake toolchain file for Emscripten..."

  cat > "${HYDRA_ROOT}/cmake/hydra_emscripten.cmake" << EOF
# hydra_emscripten.cmake - Generated by build script
# For Emscripten version: ${EMCC_VERSION}

set(CMAKE_SYSTEM_NAME Emscripten)
set(CMAKE_SYSTEM_VERSION 1)

# Specify the cross compilers
set(CMAKE_C_COMPILER emcc)
set(CMAKE_CXX_COMPILER em++)

# Where is the target environment
set(CMAKE_FIND_ROOT_PATH \$ENV{EMSDK}/upstream/emscripten)

# Search for programs in the build host directories
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)

# Search for libraries and headers in the target directories
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

# Specific flags for WebAssembly compilation - version-specific adjustments
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s WASM=1 -s EXPORT_ES6=1")
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s ALLOW_MEMORY_GROWTH=1 -s MODULARIZE=1")
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s EXPORT_NAME=HydraModule")

# For debugging
if(WASM_DEBUG)
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -g -s ASSERTIONS=1 -s SAFE_HEAP=1")
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s DEMANGLE_SUPPORT=1")
endif()

# Add support for C++20 features
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -std=c++20")

# Handle exceptions based on configuration
if(HYDRA_ENABLE_EXCEPTIONS)
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -fexceptions")
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s DISABLE_EXCEPTION_CATCHING=0")
else()
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -fno-exceptions")
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s DISABLE_EXCEPTION_CATCHING=1")
endif()

# Handle threading if needed
if(HYDRA_ENABLE_THREADING)
  set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s USE_PTHREADS=1 -s PTHREAD_POOL_SIZE=4")
endif()

# Export embind glue
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -s EXPORTED_RUNTIME_METHODS=['ccall','cwrap']")

# Set export options
set(CMAKE_EXE_LINKER_FLAGS "\${CMAKE_EXE_LINKER_FLAGS} -s EXPORT_ALL=1")

# Extra linker flags
set(CMAKE_EXE_LINKER_FLAGS "\${CMAKE_EXE_LINKER_FLAGS} --bind -s FILESYSTEM=1")
EOF

  echo "âœ… Toolchain file created"
}

# Create mock dependencies for testing
create_mock_dependencies() {
  echo "Creating mock dependencies for testing..."

  # Create directories for mock libraries
  mkdir -p "${HYDRA_ROOT}/build_wasm/mock/include/openssl"
  mkdir -p "${HYDRA_ROOT}/build_wasm/mock/include/botan"
  mkdir -p "${HYDRA_ROOT}/build_wasm/mock/include/hydra_math"
  mkdir -p "${HYDRA_ROOT}/build_wasm/mock/include/eigen3/Eigen"
  mkdir -p "${HYDRA_ROOT}/build_wasm/mock/lib"

  # Create mock GMP implementation using the real GMP header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/gmp.h" << EOF
// Mock GMP header for WebAssembly build
#pragma once

#include "/volumes/bigcode/hydra_sdk/gmp-wasm/binding/gmp/dist/include/gmp.h"
EOF

  # Create mock GMPXX implementation using the real GMPXX header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/gmpxx.h" << EOF
// Mock GMPXX header for WebAssembly build
#pragma once

#include "/volumes/bigcode/hydra_sdk/gmp-wasm/binding/gmp/src/gmpxx.h"
EOF

  # Create mock MPFR implementation using the real MPFR header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/mpfr.h" << EOF
// Mock MPFR header for WebAssembly build
#pragma once

#include "/volumes/bigcode/hydra_sdk/gmp-wasm/binding/mpfr/dist/include/mpfr.h"
EOF

  # Create mock MPF2MPFR implementation using the real MPF2MPFR header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/mpf2mpfr.h" << EOF
// Mock MPF2MPFR header for WebAssembly build
#pragma once

#include "/volumes/bigcode/hydra_sdk/gmp-wasm/binding/mpfr/dist/include/mpf2mpfr.h"
EOF

  # Create mock hydra_math/bigint.hpp using gmpxx.h
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/hydra_math/bigint.hpp" << EOF
#pragma once

#include <string>
#include <vector>
#include <cstdint>
#include <stdexcept>
#include <gmpxx.h>

namespace hydra {
namespace math {

/**
 * A BigInt implementation that uses the GMP C++ wrapper
 */
class BigInt {
private:
    mpz_class value_;

public:
    // Constructors
    BigInt() : value_(0) {}

    BigInt(int val) : value_(val) {}

    BigInt(const std::string& str, int base = 10) : value_(str, base) {}

    // Copy constructor
    BigInt(const BigInt& other) : value_(other.value_) {}

    // Move constructor
    BigInt(BigInt&& other) noexcept : value_(std::move(other.value_)) {}

    // Destructor
    ~BigInt() = default;

    // Assignment operators
    BigInt& operator=(const BigInt& other) {
        if (this != &other) {
            value_ = other.value_;
        }
        return *this;
    }

    BigInt& operator=(BigInt&& other) noexcept {
        if (this != &other) {
            value_ = std::move(other.value_);
        }
        return *this;
    }

    // Conversion to string
    std::string to_string(int base = 10) const {
        return value_.get_str(base);
    }

    // Conversion to int
    int to_int() const {
        return value_.get_si();
    }

    // Arithmetic operators
    BigInt operator+(const BigInt& other) const {
        BigInt result;
        result.value_ = value_ + other.value_;
        return result;
    }

    BigInt operator-(const BigInt& other) const {
        BigInt result;
        result.value_ = value_ - other.value_;
        return result;
    }

    BigInt operator*(const BigInt& other) const {
        BigInt result;
        result.value_ = value_ * other.value_;
        return result;
    }

    BigInt operator/(const BigInt& other) const {
        if (other.value_ == 0) {
            throw std::invalid_argument("Division by zero");
        }
        BigInt result;
        result.value_ = value_ / other.value_;
        return result;
    }

    BigInt& operator+=(const BigInt& other) {
        value_ += other.value_;
        return *this;
    }

    BigInt& operator-=(const BigInt& other) {
        value_ -= other.value_;
        return *this;
    }

    BigInt& operator*=(const BigInt& other) {
        value_ *= other.value_;
        return *this;
    }

    BigInt& operator/=(const BigInt& other) {
        if (other.value_ == 0) {
            throw std::invalid_argument("Division by zero");
        }
        value_ /= other.value_;
        return *this;
    }

    // Comparison operators
    bool operator==(const BigInt& other) const {
        return value_ == other.value_;
    }

    bool operator!=(const BigInt& other) const {
        return value_ != other.value_;
    }

    bool operator<(const BigInt& other) const {
        return value_ < other.value_;
    }

    bool operator<=(const BigInt& other) const {
        return value_ <= other.value_;
    }

    bool operator>(const BigInt& other) const {
        return value_ > other.value_;
    }

    bool operator>=(const BigInt& other) const {
        return value_ >= other.value_;
    }

    // Conversion to bytes
    std::vector<uint8_t> to_bytes() const {
        size_t count;
        void* data = mpz_export(nullptr, &count, 1, 1, 0, 0, value_.get_mpz_t());
        if (!data) {
            return std::vector<uint8_t>();
        }
        std::vector<uint8_t> result(static_cast<uint8_t*>(data), static_cast<uint8_t*>(data) + count);
        free(data);
        return result;
    }

    // Create from bytes
    static BigInt from_bytes(const std::vector<uint8_t>& bytes) {
        BigInt result;
        if (!bytes.empty()) {
            mpz_import(result.value_.get_mpz_t(), bytes.size(), 1, 1, 0, 0, bytes.data());
        }
        return result;
    }

    // Static methods
    static BigInt from_string(const std::string& str, int base = 10) {
        return BigInt(str, base);
    }

    // Access to the underlying mpz_class
    mpz_class& get_mpz_class() {
        return value_;
    }

    const mpz_class& get_mpz_class() const {
        return value_;
    }

    // For compatibility with the original BigInt implementation
    mpz_t& get_mpz_t() {
        return value_.get_mpz_t();
    }

    const mpz_t& get_mpz_t() const {
        return value_.get_mpz_t();
    }

    mpz_t* raw() {
        return &value_.get_mpz_t();
    }

    const mpz_t* raw() const {
        return &value_.get_mpz_t();
    }
};

} // namespace math
} // namespace hydra
EOF

  # Create mock OpenSSL implementation
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/openssl/ssl.h" << EOF
// Mock OpenSSL SSL header for WebAssembly build
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ssl_st SSL;
typedef struct ssl_ctx_st SSL_CTX;

SSL_CTX *SSL_CTX_new(void);
void SSL_CTX_free(SSL_CTX *ctx);
SSL *SSL_new(SSL_CTX *ctx);
void SSL_free(SSL *ssl);

#ifdef __cplusplus
}
#endif
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/openssl/crypto.h" << EOF
// Mock OpenSSL Crypto header for WebAssembly build
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
typedef struct evp_cipher_st EVP_CIPHER;

EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx);

#ifdef __cplusplus
}
#endif
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/openssl/evp.h" << EOF
// Mock OpenSSL EVP header for WebAssembly build
#pragma once

#include "crypto.h"

#ifdef __cplusplus
extern "C" {
#endif

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                   const unsigned char *key, const unsigned char *iv);
int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                     const unsigned char *in, int inl);
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                   const unsigned char *key, const unsigned char *iv);
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                     const unsigned char *in, int inl);
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

#ifdef __cplusplus
}
#endif
EOF

  # Create mock Botan headers
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/botan/auto_rng.h" << EOF
// Mock Botan Auto RNG header for WebAssembly build
#pragma once

#include <vector>
#include <memory>
#include <cstdint>

namespace Botan {

class RandomNumberGenerator {
public:
    virtual ~RandomNumberGenerator() = default;
    virtual void randomize(uint8_t output[], size_t length) {}
};

class AutoSeeded_RNG : public RandomNumberGenerator {
public:
    AutoSeeded_RNG() = default;
    ~AutoSeeded_RNG() override = default;

    void randomize(uint8_t output[], size_t length) override {}
};

} // namespace Botan
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/botan/kyber.h" << EOF
// Mock Botan Kyber header for WebAssembly build
#pragma once

#include <vector>
#include <memory>
#include <cstdint>
#include "auto_rng.h"

namespace Botan {

class DilithiumMode {
public:
    DilithiumMode(const std::string& mode) {}
};

class Dilithium_PrivateKey {
public:
    Dilithium_PrivateKey(RandomNumberGenerator& rng, const DilithiumMode& mode) {}
};

class Dilithium_PublicKey {
public:
    Dilithium_PublicKey(const Dilithium_PrivateKey& key) {}
};

class Private_Key {
public:
    virtual ~Private_Key() = default;
};

class Public_Key {
public:
    virtual ~Public_Key() = default;
};

class PK_Signer {
public:
    PK_Signer(const Private_Key& key, RandomNumberGenerator& rng, const std::string& params) {}

    void update(const uint8_t data[], size_t length) {}
    void update(const std::vector<uint8_t>& data) {}

    std::vector<uint8_t> signature(RandomNumberGenerator& rng) { return {}; }
};

class PK_Verifier {
public:
    PK_Verifier(const Public_Key& key, const std::string& params) {}

    void update(const uint8_t data[], size_t length) {}
    void update(const std::vector<uint8_t>& data) {}

    bool check_signature(const std::vector<uint8_t>& signature) { return true; }
};

class PK_KEM_Encryptor {
public:
    PK_KEM_Encryptor(const Public_Key& key, const std::string& kdf) {}

    struct EncapsulatedKey {
        std::vector<uint8_t> encapsulated_shared_key() const { return {}; }
        std::vector<uint8_t> shared_key() const { return {}; }
    };

    EncapsulatedKey encrypt(RandomNumberGenerator& rng) { return {}; }
};

class PK_KEM_Decryptor {
public:
    PK_KEM_Decryptor(const Private_Key& key, RandomNumberGenerator& rng, const std::string& kdf) {}

    std::vector<uint8_t> decrypt(const std::vector<uint8_t>& encapsulated_key) { return {}; }
};

} // namespace Botan
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/botan/hex.h" << EOF
// Mock Botan Hex header for WebAssembly build
#pragma once

#include <string>
#include <vector>

namespace Botan {

std::string hex_encode(const uint8_t data[], size_t length) {
    return "";
}

std::string hex_encode(const std::vector<uint8_t>& data) {
    return "";
}

std::vector<uint8_t> hex_decode(const std::string& hex) {
    return {};
}

} // namespace Botan
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/botan/pubkey.h" << EOF
// Mock Botan Public Key header for WebAssembly build
#pragma once

// This file is intentionally empty as the necessary classes
// are defined in kyber.h for simplicity
EOF

  # Create mock Blake3 header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/blake3.h" << EOF
// Mock Blake3 header for WebAssembly build
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    uint8_t dummy[64];
} blake3_hasher;

void blake3_hasher_init(blake3_hasher *hasher);
void blake3_hasher_update(blake3_hasher *hasher, const void *input, size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *hasher, uint8_t *out, size_t out_len);

#ifdef __cplusplus
}
#endif
EOF

  # Create mock Eigen Core header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/eigen3/Eigen/Core" << EOF
// Mock Eigen Core header for WebAssembly build
#pragma once

#include <cmath>
#include <vector>
#include <array>

namespace Eigen {

template<typename Scalar, int Rows, int Cols>
class Matrix {
public:
    Matrix() : m_data(Rows * Cols, 0) {}

    Scalar& operator()(int row, int col) {
        return m_data[row * Cols + col];
    }

    const Scalar& operator()(int row, int col) const {
        return m_data[row * Cols + col];
    }

    Matrix<Scalar, Cols, Rows> transpose() const {
        Matrix<Scalar, Cols, Rows> result;
        for (int i = 0; i < Rows; ++i) {
            for (int j = 0; j < Cols; ++j) {
                result(j, i) = (*this)(i, j);
            }
        }
        return result;
    }

private:
    std::vector<Scalar> m_data;
};

template<typename Scalar, int Size>
using Vector = Matrix<Scalar, Size, 1>;

using Matrix2d = Matrix<double, 2, 2>;
using Matrix3d = Matrix<double, 3, 3>;
using Matrix4d = Matrix<double, 4, 4>;

using Vector2d = Vector<double, 2>;
using Vector3d = Vector<double, 3>;
using Vector4d = Vector<double, 4>;

} // namespace Eigen
EOF

  # Create mock Eigen Dense header
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/eigen3/Eigen/Dense" << EOF
// Mock Eigen Dense header for WebAssembly build
#pragma once

#include "Core"
EOF

  # Create mock MPFR implementation
  cat > "${HYDRA_ROOT}/build_wasm/mock/include/mpfr.h" << EOF
// Mock MPFR header for WebAssembly build
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct { int dummy; } __mpfr_struct;
typedef __mpfr_struct mpfr_t[1];
typedef __mpfr_struct *mpfr_ptr;
typedef const __mpfr_struct *mpfr_srcptr;

typedef enum {
  MPFR_RNDN = 0,  // Round to nearest, with ties to even
  MPFR_RNDZ,      // Round toward zero
  MPFR_RNDU,      // Round toward +Inf
  MPFR_RNDD,      // Round toward -Inf
  MPFR_RNDA,      // Round away from zero
  MPFR_RNDF       // Faithful rounding
} mpfr_rnd_t;

void mpfr_init2(mpfr_ptr x, unsigned long prec);
void mpfr_clear(mpfr_ptr x);
void mpfr_set_d(mpfr_ptr rop, double op, mpfr_rnd_t rnd);
void mpfr_set(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_set_str(mpfr_ptr rop, const char *s, int base, mpfr_rnd_t rnd);
double mpfr_get_d(mpfr_srcptr op, mpfr_rnd_t rnd);
unsigned long mpfr_get_prec(mpfr_srcptr x);
int mpfr_set_prec(mpfr_ptr x, unsigned long prec);
void mpfr_swap(mpfr_ptr x, mpfr_ptr y);
int mpfr_cmp(mpfr_srcptr op1, mpfr_srcptr op2);
int mpfr_snprintf(char *buf, size_t n, const char *format, ...);
size_t mpfr_get_str_ndigits(int b, unsigned long prec);

// Arithmetic functions
int mpfr_add(mpfr_ptr rop, mpfr_srcptr op1, mpfr_srcptr op2, mpfr_rnd_t rnd);
int mpfr_sub(mpfr_ptr rop, mpfr_srcptr op1, mpfr_srcptr op2, mpfr_rnd_t rnd);
int mpfr_mul(mpfr_ptr rop, mpfr_srcptr op1, mpfr_srcptr op2, mpfr_rnd_t rnd);
int mpfr_div(mpfr_ptr rop, mpfr_srcptr op1, mpfr_srcptr op2, mpfr_rnd_t rnd);

// Mathematical functions
int mpfr_sqrt(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_pow(mpfr_ptr rop, mpfr_srcptr op1, mpfr_srcptr op2, mpfr_rnd_t rnd);
int mpfr_exp(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_log(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_sin(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_cos(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);
int mpfr_tan(mpfr_ptr rop, mpfr_srcptr op, mpfr_rnd_t rnd);

#ifdef __cplusplus
}
#endif
EOF

  cat > "${HYDRA_ROOT}/build_wasm/mock/include/mpf2mpfr.h" << EOF
// Mock MPF to MPFR compatibility header for WebAssembly build
#pragma once

#include "mpfr.h"
EOF

  # Create empty mock library files
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libgmp.a"
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libmpfr.a"
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libssl.a"
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libcrypto.a"
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libbotan-3.a"
  touch "${HYDRA_ROOT}/build_wasm/mock/lib/libblake3.a"

  echo "âœ… Mock dependencies created"
}

# Create bindings for a module
create_bindings() {
  local MODULE_NAME=$1
  local OUTPUT_DIR="${HYDRA_ROOT}/src/${MODULE_NAME}"

  case ${MODULE_NAME} in
    hydra_crypto)
      cat > "${OUTPUT_DIR}/wasm_bindings.cpp" << EOF
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <hydra_crypto/blake3_hash.hpp>

using namespace emscripten;

// Simple Blake3 hash implementation for testing
class Blake3HashWrapper {
public:
    Blake3HashWrapper() {}

    std::vector<uint8_t> hash(const std::string& input) {
        hydra::crypto::Blake3Hash hasher;
        return hasher.hash(
            reinterpret_cast<const uint8_t*>(input.c_str()),
            input.size()
        );
    }
};

EMSCRIPTEN_BINDINGS(hydra_crypto) {
    class_<Blake3HashWrapper>("Blake3Hash")
        .constructor<>()
        .function("hash", &Blake3HashWrapper::hash);

    register_vector<uint8_t>("Vector<uint8_t>");
}
EOF
      ;;

    hydra_address)
      cat > "${OUTPUT_DIR}/wasm_bindings.cpp" << EOF
#include <emscripten/bind.h>
#include <emscripten/val.h>

using namespace emscripten;

// Basic address generator for testing
class AddressGenerator {
public:
    AddressGenerator(int bitStrength) : bitStrength(bitStrength) {}

    std::string generateAddress(const std::vector<uint8_t>& publicKey) {
        // Simple address generation for testing
        std::string result = "addr_";
        for (size_t i = 0; i < 6 && i < publicKey.size(); i++) {
            char hex[3];
            snprintf(hex, sizeof(hex), "%02x", publicKey[i]);
            result += hex;
        }
        result += "_" + std::to_string(bitStrength);
        return result;
    }

private:
    int bitStrength;
};

EMSCRIPTEN_BINDINGS(hydra_address) {
    class_<AddressGenerator>("AddressGenerator")
        .constructor<int>()
        .function("generateAddress", &AddressGenerator::generateAddress);

    register_vector<uint8_t>("Vector<uint8_t>");
}
EOF
      ;;

    hydra_vfs)
      cat > "${OUTPUT_DIR}/wasm_bindings.cpp" << EOF
#include <emscripten/bind.h>
#include <emscripten/val.h>

using namespace emscripten;

// Simple VFS implementation for testing
class P2PVFS {
public:
    P2PVFS(const std::string& nodeId, const std::string& storagePath)
        : nodeId(nodeId), storagePath(storagePath) {}

    bool addPeer(const std::string& peerId, const std::string& address) {
        peers[peerId] = address;
        return true;
    }

    std::vector<std::string> getPeers() {
        std::vector<std::string> result;
        for (const auto& [id, _] : peers) {
            result.push_back(id);
        }
        return result;
    }

    val createDirectory(const std::string& path) {
        val result = val::object();
        result.set("success", true);
        result.set("value", true);
        return result;
    }

    val listFiles(const std::string& path) {
        val result = val::object();
        result.set("success", true);

        std::vector<std::string> files = {"mock_file1.js", "mock_file2.js"};
        result.set("value", val::array(files));

        return result;
    }

    void synchronize() {
        // Mock implementation
    }

private:
    std::string nodeId;
    std::string storagePath;
    std::map<std::string, std::string> peers;
};

EMSCRIPTEN_BINDINGS(hydra_vfs) {
    class_<P2PVFS>("P2PVFS")
        .constructor<std::string, std::string>()
        .function("addPeer", &P2PVFS::addPeer)
        .function("getPeers", &P2PVFS::getPeers)
        .function("createDirectory", &P2PVFS::createDirectory)
        .function("listFiles", &P2PVFS::listFiles)
        .function("synchronize", &P2PVFS::synchronize);
}
EOF
      ;;
  esac

  echo "âœ… Created bindings for ${MODULE_NAME}"
}

# Build a module
build_module() {
  local MODULE_NAME=$1
  echo "Building ${MODULE_NAME}..."

  # Create build directory for this module
  local MODULE_BUILD_DIR="${BUILD_DIR}/${MODULE_NAME}"
  mkdir -p "${MODULE_BUILD_DIR}"

  # Generate bindings
  create_bindings "${MODULE_NAME}"

  # Enter build directory
  cd "${MODULE_BUILD_DIR}"

  # Set CMake flags
  local CMAKE_FLAGS="-DCMAKE_TOOLCHAIN_FILE=${HYDRA_ROOT}/cmake/hydra_emscripten.cmake"
  CMAKE_FLAGS+=" -DCMAKE_BUILD_TYPE=$([ $DEBUG -eq 1 ] && echo Debug || echo Release)"
  CMAKE_FLAGS+=" -DHYDRA_WASM_BINDINGS=ON"
  CMAKE_FLAGS+=" -DHYDRA_ENABLE_EXCEPTIONS=ON"

  if [ $DEBUG -eq 1 ]; then
    CMAKE_FLAGS+=" -DWASM_DEBUG=ON"
  fi

  # Prepare module-specific mock directory
  local MOCK_DIR="${BUILD_DIR}/mock"

  # Check if we have WebAssembly-compiled libraries
  WASM_LIB_DIR="${HYDRA_ROOT}/lib/wasm"

  # Use WebAssembly-compiled libraries if available, otherwise use mocks
  if [ -d "${WASM_LIB_DIR}" ]; then
    echo "Using WebAssembly-compiled libraries from ${WASM_LIB_DIR}"

    # GMP
    GMP_INCLUDE_DIR="${WASM_LIB_DIR}/include"
    GMP_LIBRARY="${WASM_LIB_DIR}/lib/libgmp.a"

    # MPFR
    MPFR_INCLUDE_DIR="${WASM_LIB_DIR}/include"
    MPFR_LIBRARY="${WASM_LIB_DIR}/lib/libmpfr.a"

    # OpenSSL
    OPENSSL_INCLUDE_DIR="${WASM_LIB_DIR}/include"
    OPENSSL_CRYPTO_LIBRARY="${WASM_LIB_DIR}/lib/libcrypto.a"
    OPENSSL_SSL_LIBRARY="${WASM_LIB_DIR}/lib/libssl.a"
    OPENSSL_ROOT_DIR="${WASM_LIB_DIR}"

    # Botan
    BOTAN_INCLUDE_DIR="${WASM_LIB_DIR}/include/botan-3"
    BOTAN_LIBRARY="${WASM_LIB_DIR}/lib/libbotan-3.a"

    # Blake3
    BLAKE3_INCLUDE_DIR="${WASM_LIB_DIR}/include"
    BLAKE3_LIBRARY="${WASM_LIB_DIR}/lib/libblake3.a"

    # Eigen
    EIGEN3_INCLUDE_DIR="${WASM_LIB_DIR}/include/eigen3"

    # JSON
    JSON_INCLUDE_DIR="${WASM_LIB_DIR}/include"
  else
    echo "Using mock libraries from ${MOCK_DIR}"

    # GMP
    GMP_INCLUDE_DIR="${MOCK_DIR}/include"
    GMP_LIBRARY="${MOCK_DIR}/lib/libgmp.a"

    # MPFR
    MPFR_INCLUDE_DIR="${MOCK_DIR}/include"
    MPFR_LIBRARY="${MOCK_DIR}/lib/libmpfr.a"

    # OpenSSL
    OPENSSL_INCLUDE_DIR="${MOCK_DIR}/include"
    OPENSSL_CRYPTO_LIBRARY="${MOCK_DIR}/lib/libcrypto.a"
    OPENSSL_SSL_LIBRARY="${MOCK_DIR}/lib/libssl.a"
    OPENSSL_ROOT_DIR="${MOCK_DIR}"

    # Botan
    BOTAN_INCLUDE_DIR="${MOCK_DIR}/include"
    BOTAN_LIBRARY="${MOCK_DIR}/lib/libbotan-3.a"

    # Blake3
    BLAKE3_INCLUDE_DIR="${MOCK_DIR}/include"
    BLAKE3_LIBRARY="${MOCK_DIR}/lib/libblake3.a"

    # Eigen
    EIGEN3_INCLUDE_DIR="${MOCK_DIR}/include/eigen3"

    # JSON
    JSON_INCLUDE_DIR="${MOCK_DIR}/include"
  fi

  # Run CMake configure
  local SRC_DIR="${HYDRA_ROOT}/src/${MODULE_NAME}"

  # Use lmvs_wasm directory for lmvs module
  if [ "${MODULE_NAME}" = "lmvs" ]; then
    SRC_DIR="${HYDRA_ROOT}/src/lmvs_wasm"
  fi

  if [ $VERBOSE -eq 1 ]; then
    emcmake cmake "${SRC_DIR}" ${CMAKE_FLAGS} \
      -DGMP_INCLUDE_DIR="${GMP_INCLUDE_DIR}" \
      -DGMP_LIBRARY="${GMP_LIBRARY}" \
      -DMPFR_INCLUDE_DIR="${MPFR_INCLUDE_DIR}" \
      -DMPFR_LIBRARY="${MPFR_LIBRARY}" \
      -DOPENSSL_INCLUDE_DIR="${OPENSSL_INCLUDE_DIR}" \
      -DOPENSSL_CRYPTO_LIBRARY="${OPENSSL_CRYPTO_LIBRARY}" \
      -DOPENSSL_SSL_LIBRARY="${OPENSSL_SSL_LIBRARY}" \
      -DOPENSSL_ROOT_DIR="${OPENSSL_ROOT_DIR}" \
      -DBOTAN_INCLUDE_DIR="${BOTAN_INCLUDE_DIR}" \
      -DBOTAN_LIBRARY="${BOTAN_LIBRARY}" \
      -DBLAKE3_INCLUDE_DIR="${BLAKE3_INCLUDE_DIR}" \
      -DBLAKE3_LIBRARY="${BLAKE3_LIBRARY}" \
      -DEIGEN3_INCLUDE_DIR="${EIGEN3_INCLUDE_DIR}" \
      -DHYDRA_MATH_INCLUDE_DIR="${MOCK_DIR}/include" \
      -DHYDRA_WASM_BUILD=ON \
      -DCMAKE_CXX_FLAGS="-I${GMP_INCLUDE_DIR} -I${MPFR_INCLUDE_DIR} -I${BOTAN_INCLUDE_DIR} -I${JSON_INCLUDE_DIR}" \
      -DCMAKE_EXE_LINKER_FLAGS="-s WASM=1 -s EXPORT_ES6=1 -s ALLOW_MEMORY_GROWTH=1 -s MODULARIZE=1 -s EXPORT_NAME=HydraModule -s EXPORTED_RUNTIME_METHODS=['ccall','cwrap'] --emit-symbol-map"
  else
    emcmake cmake "${SRC_DIR}" ${CMAKE_FLAGS} \
      -DGMP_INCLUDE_DIR="${GMP_INCLUDE_DIR}" \
      -DGMP_LIBRARY="${GMP_LIBRARY}" \
      -DMPFR_INCLUDE_DIR="${MPFR_INCLUDE_DIR}" \
      -DMPFR_LIBRARY="${MPFR_LIBRARY}" \
      -DOPENSSL_INCLUDE_DIR="${OPENSSL_INCLUDE_DIR}" \
      -DOPENSSL_CRYPTO_LIBRARY="${OPENSSL_CRYPTO_LIBRARY}" \
      -DOPENSSL_SSL_LIBRARY="${OPENSSL_SSL_LIBRARY}" \
      -DOPENSSL_ROOT_DIR="${OPENSSL_ROOT_DIR}" \
      -DBOTAN_INCLUDE_DIR="${BOTAN_INCLUDE_DIR}" \
      -DBOTAN_LIBRARY="${BOTAN_LIBRARY}" \
      -DBLAKE3_INCLUDE_DIR="${BLAKE3_INCLUDE_DIR}" \
      -DBLAKE3_LIBRARY="${BLAKE3_LIBRARY}" \
      -DEIGEN3_INCLUDE_DIR="${EIGEN3_INCLUDE_DIR}" \
      -DHYDRA_MATH_INCLUDE_DIR="${MOCK_DIR}/include" \
      -DHYDRA_WASM_BUILD=ON \
      -DCMAKE_CXX_FLAGS="-I${GMP_INCLUDE_DIR} -I${MPFR_INCLUDE_DIR} -I${BOTAN_INCLUDE_DIR} -I${JSON_INCLUDE_DIR}" \
      -DCMAKE_EXE_LINKER_FLAGS="-s WASM=1 -s EXPORT_ES6=1 -s ALLOW_MEMORY_GROWTH=1 -s MODULARIZE=1 -s EXPORT_NAME=HydraModule -s EXPORTED_RUNTIME_METHODS=['ccall','cwrap'] --emit-symbol-map" > /dev/null
  fi

  # Build
  if [ $VERBOSE -eq 1 ]; then
    emmake make -j4
  else
    emmake make -j4 > /dev/null
  fi

  # Create output directory
  mkdir -p "${OUTPUT_DIR}/${MODULE_NAME}"

  # Copy output to modules directory (adjusted for mock build)
  echo "Copying generated files to ${OUTPUT_DIR}/${MODULE_NAME}/"
  cp -f ./*.js "${OUTPUT_DIR}/${MODULE_NAME}/" 2>/dev/null || true
  cp -f ./*.wasm "${OUTPUT_DIR}/${MODULE_NAME}/" 2>/dev/null || true

  echo "âœ… ${MODULE_NAME} build completed"
  cd "${HYDRA_ROOT}"
}

# Main build process
echo "===== Hydra SDK WebAssembly Build ====="
echo "Building for Emscripten ${EMCC_VERSION}"
echo "Module(s): ${MODULE}"
echo "Debug mode: $([ $DEBUG -eq 1 ] && echo enabled || echo disabled)"
echo "============================================="

# Create required files
create_toolchain_file
create_mock_dependencies

# Build selected modules
case ${MODULE} in
  all)
    build_module "hydra_crypto"
    build_module "hydra_address"
    build_module "hydra_vfs"
    build_module "lmvs"
    ;;
  crypto)
    build_module "hydra_crypto"
    ;;
  address)
    build_module "hydra_address"
    ;;
  vfs)
    build_module "hydra_vfs"
    ;;
  lmvs)
    build_module "lmvs"
    ;;
  *)
    echo "Error: Unknown module '${MODULE}'"
    echo "Available modules: crypto, address, vfs, lmvs, all"
    exit 1
    ;;
esac

echo "============================================="
echo "âœ… All requested modules built successfully!"
echo "Output available in: ${OUTPUT_DIR}"

# Create a simple test page
TEST_PAGE="${OUTPUT_DIR}/test.html"
cat > "${TEST_PAGE}" << EOF
<!DOCTYPE html>
<html>
<head>
  <title>Hydra WASM Test</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    .module { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
    .result { font-family: monospace; white-space: pre; background: #f5f5f5; padding: 10px; }
  </style>
</head>
<body>
  <h1>Hydra WASM Test</h1>

  <div class="module">
    <h2>Crypto Module Test</h2>
    <button id="cryptoTest">Run Test</button>
    <div id="cryptoResult" class="result"></div>
  </div>

  <div class="module">
    <h2>Address Module Test</h2>
    <button id="addressTest">Run Test</button>
    <div id="addressResult" class="result"></div>
  </div>

  <div class="module">
    <h2>VFS Module Test</h2>
    <button id="vfsTest">Run Test</button>
    <div id="vfsResult" class="result"></div>
  </div>

  <div class="module">
    <h2>LMVS Module Test</h2>
    <button id="lmvsTest">Run Test</button>
    <div id="lmvsResult" class="result"></div>
  </div>

  <script type="module">
    // Crypto Module
    document.getElementById('cryptoTest').addEventListener('click', async () => {
      try {
        const cryptoModule = await import('./hydra_crypto/hydra_crypto.js');
        const CryptoModule = await cryptoModule.default();

        const hasher = new CryptoModule.Blake3Hash();
        const result = hasher.hash("Hydra Crypto Test");

        const hex = Array.from(result).map(b => b.toString(16).padStart(2, '0')).join('');
        document.getElementById('cryptoResult').textContent = 'Hash: ' + hex;
      } catch (error) {
        document.getElementById('cryptoResult').textContent = 'Error: ' + error.message;
      }
    });

    // Address Module
    document.getElementById('addressTest').addEventListener('click', async () => {
      try {
        const addressModule = await import('./hydra_address/hydra_address.js');
        const AddressModule = await addressModule.default();

        const generator = new AddressModule.AddressGenerator(128);

        // Create a test public key (random bytes)
        const publicKey = new Uint8Array(32);
        crypto.getRandomValues(publicKey);

        const address = generator.generateAddress(publicKey);
        document.getElementById('addressResult').textContent = 'Generated Address: ' + address;
      } catch (error) {
        document.getElementById('addressResult').textContent = 'Error: ' + error.message;
      }
    });

    // VFS Module
    document.getElementById('vfsTest').addEventListener('click', async () => {
      try {
        const vfsModule = await import('./hydra_vfs/hydra_vfs.js');
        const VFSModule = await vfsModule.default();

        const vfs = new VFSModule.P2PVFS("browser-node", "/virtual/storage");
        vfs.addPeer("test-peer", "localhost:8000");

        const peers = vfs.getPeers();
        const files = vfs.listFiles("/");

        let output = 'Node initialized\n';
        output += 'Peers: ' + peers.join(', ') + '\n';
        output += 'Files: ' + files.value.join(', ') + '\n';

        document.getElementById('vfsResult').textContent = output;
      } catch (error) {
        document.getElementById('vfsResult').textContent = 'Error: ' + error.message;
      }
    });

    // LMVS Module
    document.getElementById('lmvsTest').addEventListener('click', async () => {
      try {
        const lmvsModule = await import('./lmvs/lmvs.js');
        const LMVSModule = await lmvsModule.default();

        // Create an LMVS instance with 3 layers and vector size 32
        const lmvs = LMVSModule.createLMVS(3, 32);

        // Get LMVS information
        const numLayers = LMVSModule.getLMVSNumLayers(lmvs);
        const vectorSize = LMVSModule.getLMVSVectorSize(lmvs);
        const lmvsInfo = LMVSModule.getLMVSString(lmvs);

        // Generate a vector
        const vector = LMVSModule.generateLMVSVector(lmvs);

        // Multiply the vector
        const result = LMVSModule.multiplyLMVSVector(lmvs, vector);

        let output = lmvsInfo + '\n';
        output += 'Generated vector: [' + vector.slice(0, 5).join(', ') + '...]\n';
        output += 'Multiplication result: [' + result.slice(0, 5).join(', ') + '...]\n';

        // Clean up
        LMVSModule.destroyLMVS(lmvs);

        document.getElementById('lmvsResult').textContent = output;
      } catch (error) {
        document.getElementById('lmvsResult').textContent = 'Error: ' + error.message;
      }
    });
  </script>
</body>
</html>
EOF

echo "Created test page at: ${TEST_PAGE}"
echo "To test, serve the '${OUTPUT_DIR}' directory with a local web server"
echo "For example:"
echo "  cd ${OUTPUT_DIR} && python3 -m http.server 8080"
echo "Then open http://localhost:8080/test.html in your browser"